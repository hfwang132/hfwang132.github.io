[{"categories":["Diary"],"content":" Projects Date Remark An FM Radio Receiver based on PYNQ-Z2 and RTL-SDR Jun 2023 Jupyter Notebook App rather than web app WIFI Weather Clock Jan 2023 Haven’t learned LvGL yet … The GUI is rather simple Light Cube Jan 2023 Ordered the BOM and soldered them together, but the firmware is not mine … Conway’s Game of Life Dec 2022 Touch screen used~ ","date":"2023-07-06","objectID":"/side_proj/:0:0","tags":["Embedded Systems"],"title":"Some fun side-projects","uri":"/side_proj/"},{"categories":["EECS"],"content":"1 Basics SPI has three-wire mode and four-wire mode. The three-wire mode consists of three wires - SS (Slave Select), SCK (SPI Clock), and MOSI (Master-In-Slave-Out). The four wire mode has an extra line called MISO (Master-In-Slave-Out). Signals Full Name SS Slave Select SCK SPI Clock MOSI Master-Out-Slave-In MISO Master-In-Slave-Out SPI clock has four modes: CPOL=0/1 and CPHA=0/1. CPOL stands for clock polarity – clock low or high when in idle. CPHA stands for clock phase – data valid at 0 degree or 180 degrees. ","date":"2023-07-01","objectID":"/spi/:0:1","tags":["SPI","Embedded Systems"],"title":"HW \u0026 SW Design of the AXI Quad SPI IP Core","uri":"/spi/"},{"categories":["EECS"],"content":"2 AXI Quad SPI IP Core When we run out of Zynq PS SPI controllers for some reason, we can turn to PL SPI IP cores, which is called AXI Quad SPI. AXI Quad SPI IP core In the picture, io1_i connects to MISO; ext_spi_clk and s_axi_clk can be connected to a same system clock. ip2intc_irpt can be connected to the Zynq interrupt pl_ps_irq. You can double-click on the IP core to configure clock divider, number of slave selects, and more. ","date":"2023-07-01","objectID":"/spi/:0:2","tags":["SPI","Embedded Systems"],"title":"HW \u0026 SW Design of the AXI Quad SPI IP Core","uri":"/spi/"},{"categories":["EECS"],"content":"3 Bare-Metal Programming The programming sequence is as follows: First, initialize the SPI controller. Set the value of all registers to their default values. Next, depending on your needs, configure the SPI controller. For example, the clock mode (CPHA and CPOL) and slave select mode (auto or manual). Then, depending on the number of bytes need to be written and read, write to the DTR (Data Transmit Register) the corresponding number of bytes. Each written byte will be shifted into the TX FIFO. Note: If the number of written bytes is n_tx and the number of read bytes is n_rx, then we should not only write n_tx bytes to the DTR, but also write another n_rx “dummy” bytes. This is because SPI, in nature, is a full-duplex protocol – in order to receive n_rx bytes, you also need to send n_rx bytes. Finally, read the bytes out of the DRR (Data Receive Register). When the DRR is read, the read byte will be dequed. Note: depending on the scene, when receiving from the slave, the programmer may need to discard the first n_tx bytes. This is because when the master is sending data/instructions, the slave may not yet respond. Rather, the slave will not respond until the master has sent all of the bytes (instruction \u0026 data). But due to the full-duplex nature of the SPI protocol, the first n_tx dummy bytes will also be pushed into the RX FIFO. Therefore, one may need to discard those bytes. If we use the manual slave select mode, we should assert the SS signal before the transfer and de-assert the SS signal after the transfer. The following code sends two bytes [0x00 0x37] to the slave and reads one byte from the slave. #include \"xspi.h\" // axi quad spi #include \"xparameters.h\" #include \"xstatus.h\" #include \"xplatform_info.h\" #include \"xil_printf.h\" #include \"sleep.h\" #define SPI_DEVICE_ID XPAR_SPI_0_DEVICE_ID #define SPI_BASEADDR XPAR_SPI_0_BASEADDR XSpi Spi; int main() { /* * SPI Initialize */ XSpi_Config *spi_config_ptr; spi_config_ptr = XSpi_LookupConfig(SPI_DEVICE_ID); if (spi_config_ptr == NULL) { return XST_DEVICE_NOT_FOUND; } status = XSpi_CfgInitialize(\u0026Spi, spi_config_ptr, spi_config_ptr-\u003eBaseAddress); if (status != XST_SUCCESS) { return XST_FAILURE; } // Start the SPI driver so that the device is enabled. XSpi_Start(\u0026Spi); // Disable Global interrupt to use polled mode operation XSpi_IntrGlobalDisable(\u0026Spi); /* * 1. Enable master mode. * 2. CPHA = 1, CPOL = 0 * 3. Manual Slave Select * 4. TX/RX FIFO Reset */ u32 control; control = XSpi_ReadReg(SPI_BASEADDR, XSP_CR_OFFSET); control |= XSP_CR_MASTER_MODE_MASK | // Master Mode XSP_CR_CLK_PHASE_MASK | // Clock Phase XSP_CR_MANUAL_SS_MASK | // Manual Slave Select XSP_CR_TXFIFO_RESET_MASK| // TX FIFO Reset XSP_CR_RXFIFO_RESET_MASK // RX FIFO Reset ; XSpi_WriteReg(SPI_BASEADDR, XSP_CR_OFFSET, control); // write [0x00 0x37] and then read one byte XSpi_WriteReg(SPI_BASEADDR, XSP_DTR_OFFSET, 0x00); XSpi_WriteReg(SPI_BASEADDR, XSP_DTR_OFFSET, 0x37); XSpi_WriteReg(SPI_BASEADDR, XSP_DTR_OFFSET, 0x00); /* * SPI write */ XSpi_WriteReg(SPI_BASEADDR, XSP_SSR_OFFSET, 0xE); // slave select // 0xE: 0b1110 // initiate a transfer control = XSpi_ReadReg(SPI_BASEADDR, XSP_CR_OFFSET); control |= XSP_CR_ENABLE_MASK; control \u0026= ~XSP_CR_TRANS_INHIBIT_MASK; XSpi_WriteReg(SPI_BASEADDR, XSP_CR_OFFSET, control); /* * SPI read */ // wait for the transmit FIFO to be empty while (!(XSpi_ReadReg(SPI_BASEADDR, XSP_SR_OFFSET) \u0026 XSP_SR_TX_EMPTY_MASK)); control = XSpi_ReadReg(SPI_BASEADDR, XSP_CR_OFFSET); control |= XSP_CR_TRANS_INHIBIT_MASK; XSpi_WriteReg(SPI_BASEADDR, XSP_CR_OFFSET, control); // read data receive register while ((XSpi_ReadReg(SPI_BASEADDR, XSP_SR_OFFSET) \u0026 XSP_SR_RX_EMPTY_MASK) == 0) { data = XSpi_ReadReg(SPI_BASEADDR, XSP_DRR_OFFSET); } // we know (in advance) that the slave will return one byte, so we know this loop will be executed three times. // slave de-select XSpi_WriteReg(SPI_BASEADDR, XSP_SSR_OFFSET, 0xF); // 0xF: 0b1111 xil_printf(\"MISO: 0x%x\\n\\r\", data); return 0; } ","date":"2023-07-01","objectID":"/spi/:0:3","tags":["SPI","Embedded Systems"],"title":"HW \u0026 SW Design of the AXI Quad SPI IP Core","uri":"/spi/"},{"categories":["EECS"],"content":"4 Linux Programming In order to use the AXI Quad SPI IP core in Linux, we should add a spidev node to the device tree, so that we could achieve SPI communication by reading from or writing to the /dev/spidevx.y device. In /dev/spidevx.y, x stands for the x-th SPI controller, and y stands for the y-th chip. The device tree is usually initialized during boot-up and is read-only. However, after the 4.14 version of the Linux kernel, we can use the “device tree overlay” (briefed as DTO from now on) to dynamically add incremental device trees. Below is a code snippet of DTO. /dts-v1/; /plugin/; / { fragment@0 { target = \u003c\u0026amba\u003e; overlay0: __overlay__ { axi_quad_spi_0: axi_quad_spi@80000000 { ... status = \"okay\"; #address-cells = \u003c1\u003e; #size-cells = \u003c0\u003e; spidev0: spidev@0 { compatible = \"spidev\"; reg = \u003c0\u003e; spi-max-frequency = \u003c5000000\u003e; }; }; }; }; }; Some points to be noted: We should add one more line /plugin/; after /dts-v1/; to show that this is an DTO file rather than an ordinary device tree file. target stands for which node is to be modified. Here it is \u003c\u0026amba\u003e, and it will be extended to the phandle of the node which has the symbol amba. For example, if the phandle of amba is 70, then \u003c\u0026amba\u003e virtually stands for \u003c70\u003e. A phandle uniquely denotes a node and is usually allocated by the device tree compiler. In most cases, we should add the -@ compiler option, which enables support for symbol. Otherwise we can only reference the nodes by their phandle, which requires de-compiling the device tree binaries. ","date":"2023-07-01","objectID":"/spi/:0:4","tags":["SPI","Embedded Systems"],"title":"HW \u0026 SW Design of the AXI Quad SPI IP Core","uri":"/spi/"},{"categories":["CS"],"content":"Let’s look at a code snippet in the Jupyter Notebook: import time import ipywidgets as widgets from IPython.display import display slider = widgets.IntSlider() display(slider) while True: print(slider.value) time.sleep(1) IntSlider is an interactive Jupyter Notebook widget. When the user interacts with the slider, the slider value should change. However, if you run the above codes, you will find that the printed value of the slider won’t change at all – it will be stuck at its initial value. In fact, the UI elements won’t be updated until all code blocks are finished executing. In other words, the update of the UI elements is blocked by the execution of any code block. In order to poll the states of UI elements inside a running loop, we can use the jupyter-ui-poll library. The modified codes are as follows: import time import ipywidgets as widgets from IPython.display import display from jupyter_ui_poll import ui_events slider = widgets.IntSlider() display(slider) while True: with ui_events() as poll: poll(1) # poll one event print(slider.value) time.sleep(1) ","date":"2023-07-01","objectID":"/ui_poll/:0:0","tags":["Python","Jupyter Notebook"],"title":"Polling Jupyter Widget UI Events in Runtime","uri":"/ui_poll/"},{"categories":null,"content":"Still Working on it :) ","date":"2023-06-22","objectID":"/publication/:0:1","tags":null,"title":"Publication","uri":"/publication/"},{"categories":["CS"],"content":"Recently, I have been using Python coroutines/asynchronous programming in a project. Now, I will summarize my experience. ","date":"2023-06-13","objectID":"/python_asyncio/:0:0","tags":["Python"],"title":"Python coroutines and asyncio","uri":"/python_asyncio/"},{"categories":["CS"],"content":"Import import asyncio If asyncio is to be used in an IPython environment, we have to add two more lines： import nest_asyncio nest_asyncio.apply() import asyncio ","date":"2023-06-13","objectID":"/python_asyncio/:1:0","tags":["Python"],"title":"Python coroutines and asyncio","uri":"/python_asyncio/"},{"categories":["CS"],"content":"Coroutines Coroutines are the core of asynchronous programming in Python. To define a coroutine, you need to use async def. async def main(): # do something print(\"Hello world!\") To execute the coroutine, you cannot directly call main(). Instead, you need to use run(): asyncio.run(main()) To nest one coroutine within another, similar to nesting one function within another, you can use await: import asyncio async def coro_1(): print(\"I am the coroutine 1.\") async def coro_2(): print(\"I am the coroutine 2.\") async def main(): await coro_1() await coro_2() print(\"Hello World!\") asyncio.run(main()) When nesting coroutines within another coroutine, you need to use await to invoke them. If you write it directly as follows: async def main(): coro_1() coro_2() print(\"Hello World!\") You will receive the following warnings: 01.py:10: RuntimeWarning: coroutine 'coro_1' was never awaited coro_1() RuntimeWarning: Enable tracemalloc to get the object allocation traceback 01.py:11: RuntimeWarning: coroutine 'coro_2' was never awaited coro_2() RuntimeWarning: Enable tracemalloc to get the object allocation traceback Hello World! As can been seen, coro_1 and coro_2 has not been called. ","date":"2023-06-13","objectID":"/python_asyncio/:2:0","tags":["Python"],"title":"Python coroutines and asyncio","uri":"/python_asyncio/"},{"categories":["CS"],"content":"Tasks We would lose the point if we use coroutines in the way as shown in the previous section. The true significance of coroutines lies in their ability to be executed concurrently. Consider the following code: import asyncio async def coro_1(): print(\"I am the coroutine 1.\") async def coro_2(): print(\"I am the coroutine 2.\") async def main(): task_1 = asyncio.create_task(coro_1()) task_2 = asyncio.create_task(coro_2()) await task_1 await task_2 print(\"Hello World!\") asyncio.run(main()) In this code, we used create_task to create tasks task_1 and task_2 for coro_1 and coro_2 respectively. They are actually executed together. To verify this, we can add some delays: import asyncio import time async def coro_1(): print(\"I am the coroutine 1.\") await asyncio.sleep(1) async def coro_2(): print(\"I am the coroutine 2.\") await asyncio.sleep(1) async def main(): st = time.time() task_1 = asyncio.create_task(coro_1()) task_2 = asyncio.create_task(coro_2()) await task_1 await task_2 et = time.time() print(\"Elapsed: %f s\" % (et - st)) asyncio.run(main()) The results are: I am the coroutine 1. I am the coroutine 2. Elapsed: 1.001298 s If we do not use create_task but rather directly await the two coroutines: import asyncio import time async def coro_1(): print(\"I am the coroutine 1.\") await asyncio.sleep(1) async def coro_2(): print(\"I am the coroutine 2.\") await asyncio.sleep(1) async def main(): st = time.time() await coro_1() await coro_2() et = time.time() print(\"Elapsed: %f s\" % (et - st)) asyncio.run(main()) Then the outcomes are: I am the coroutine 1. I am the coroutine 2. Elapsed: 2.002527 s In other words, if we don’t use create_task to create tasks, coro_2() will not be executed until coro_1() has finished. From this example, we can observe that the true meaning of await is “wait for the task to complete”. Furthermore, we can use gather to run multiple coroutines concurrently: import asyncio async def coro_1(): print(\"Coroutine 1 starts\") await asyncio.sleep(1) print(\"Coroutine 1 finishes\") async def coro_2(): print(\"Coroutine 2 starts\") await asyncio.sleep(2) print(\"Coroutine 2 finishes\") async def main(): print(\"Starting main coroutine\") await asyncio.gather(coro_1(), coro_2()) print(\"Main coroutine finished\") asyncio.run(main()) ","date":"2023-06-13","objectID":"/python_asyncio/:3:0","tags":["Python"],"title":"Python coroutines and asyncio","uri":"/python_asyncio/"},{"categories":["CS"],"content":"Asynchronous For loop Now we can look at async for. import asyncio import time async def async_generator(): for i in range(10): await asyncio.sleep(1) yield i async def custom_coroutine(): async for item in async_generator(): print(item) time.sleep(1) st = time.time() asyncio.run(custom_coroutine()) et = time.time() print(\"Elasped: %f s\" % (et - st)) The result is: 0 1 2 3 4 5 6 7 8 9 Elasped: 10.013134 s By combining async for and yield, we can create an asynchronous generator. In reality, an asynchronous generator is an instance of a class that has __aiter__ and __anext__ methods. Here’s an equivalent implementation of the previous code: import asyncio import time class AsyncGenerator: def __init__(self, N): self.i = 0 self.N = N def __aiter__(self): return self async def __anext__(self): i = self.i if i \u003e= self.N: raise StopAsyncIteration await asyncio.sleep(1) self.i += 1 return i async def main(): async for p in AsyncGenerator(10): print(p) st = time.time() asyncio.run(main()) et = time.time() print(\"Elasped: %f s\" % (et - st)) ","date":"2023-06-13","objectID":"/python_asyncio/:3:1","tags":["Python"],"title":"Python coroutines and asyncio","uri":"/python_asyncio/"},{"categories":["CS"],"content":"Example At last, I will give an example of using asyncio in a project: sdr = RtlSdr() sdr.center_freq = 92_700_000 # an FM radio station running at 92.7MHz async def main(): async for data in sdr.stream(): # perform FM demodulation audio = fm_demodulation(data) # play the audio display(Audio(audio, autoplay=True, rate=48000, normalize=False)) asyncio.run(main()) This is an FM radio application that uses async for to read data from the receiver, demodulate the data into audio signals and finally play the audio in a streamed manner. In other words, we are essentially processing and streaming the audio data in real time. ","date":"2023-06-13","objectID":"/python_asyncio/:4:0","tags":["Python"],"title":"Python coroutines and asyncio","uri":"/python_asyncio/"},{"categories":["EECS"],"content":"Windows Set a network adapter that can access the internet in the Control Panel and share it with Ethernet. The IP address of Ethernet will change to 192.168.137.1 (this is the default behavior in Windows). Then, set the gateway as 192.168.137.1 in the terminal of the development board: sudo route add default gw 192.168.137.1 Set the IP address as 192.168.137.x, where x is any value except 1 and 255 (gateway address and broadcast address): sudo ifconfig \u003cyour-ifdev\u003e 192.168.3.x If it still doesn’t work, check if the DNS in /etc/resolv.conf is correct. You can add a line: nameserver 8.8.8.8 ","date":"2023-06-12","objectID":"/boards_networking/:0:1","tags":["Networking","Linux"],"title":"Access the Internet from evaluation boards via PC","uri":"/boards_networking/"},{"categories":["EECS"],"content":"Ubuntu Change the IPv4 of Ethernet in the PC’s network settings to shared mode. The IP address of Ethernet will change to 10.42.0.1 (this is default in Ubuntu Linux, but I’m not sure if it is the same in other Linux distributions). Then, set the gateway as 10.42.0.1 in the terminal of the development board: sudo route add default gw 10.42.0.1 Set the IP address to any IP within the same subnet, as long as the subnet part of the IP is not the gateway address and broadcast address: sudo ifconfig 10.42.0.2 If it still doesn’t work, check if the DNS in /etc/resolv.conf is correct. You can add a line: nameserver 8.8.8.8 ","date":"2023-06-12","objectID":"/boards_networking/:0:2","tags":["Networking","Linux"],"title":"Access the Internet from evaluation boards via PC","uri":"/boards_networking/"},{"categories":["EECS"],"content":"Troubleshooting First, check if you can ping the host. If you can’t ping the host, the gateway may not be set correctly. If you can ping the host but not the external IP, it may be because you haven’t shared the Ethernet for the development board in the PC, or the proxy is not set correctly, or the gateway is not set correctly. If you can ping the external IP but not the domain name, it is most likely a DNS configuration issue. ","date":"2023-06-12","objectID":"/boards_networking/:0:3","tags":["Networking","Linux"],"title":"Access the Internet from evaluation boards via PC","uri":"/boards_networking/"},{"categories":["CS"],"content":"Xilinx’s toolchain consumes soooo much memory! Sometimes it causes the system to freeze… After all, my laptop only has 8GB of RAM. So there’s no other choice but to add virtual memories. After increase the swapfile, the system performance has improved a lot: sudo swapoff /swapfile sudo dd if=/dev/zero of=/swapfile bs=1M count=16384 sudo mkswap /swapfile sudo swapon /swapfile ","date":"2023-06-12","objectID":"/increase_swapfile/:0:0","tags":["Storage/Partition","Linux"],"title":"Increasing the swapfile for Linux","uri":"/increase_swapfile/"},{"categories":["EECS"],"content":"To partition and format an SD card in Linux, follow these steps: First, connect the SD card to your PC. Then, use the fdisk command in the bash command line to partition the SD card. Finally, use the mkfs command to create a file system (format) on the SD card. The main commands are as follows: First, use sudo fdisk -l to confirm which device in /dev corresponds to the SD card. Assuming we have determined that the SD card corresponds to /dev/sde, we can enter sudo fdisk /dev/sde to start the partitioning operation: Enter d to delete partitions. Keep entering until all partitions are deleted. Enter n to create the first partition as the boot partition. Enter t to change the partition type to W95 FAT32. Boot partitions are generally of this type. Enter a to set the partition as the boot partition. Enter n to create the second partition as the root file system partition. Since the root file system partition type is usually Linux, and the default partition type is already Linux, there is no need to enter t to change the partition type. Enter w to save and exit. Finally, after partitioning, we can create the file systems: sudo mkfs.vfat -F 32 -n \"BOOT\" /dev/sde1 sudo mkfs.ext4 -L \"rootfs\" /dev/sde2 In the above code, the first line creates a FAT32 file system for the boot partition and names it as BOOT. The second line creates an ext4 file system for the root file system partition and names it as rootfs. ","date":"2023-06-12","objectID":"/linux_sd_card/:0:0","tags":["Storage/Partition","Linux"],"title":"Partitioning and Formatting SD Cards with Linux","uri":"/linux_sd_card/"},{"categories":["CS"],"content":"To mount the EFI partitions, run the following commands in PowerShell: diskpart list disk # make sure which is the disk that contains the EFI partition. usually 0 select disk 0 list partition # make sure which is the EFI partition. normally 0 select disk 0 assign letter=z Then we will mount the EFI partition as drive Z. This operation may be useful when using a dual-boot system with Windows and Ubuntu: Sometimes, after removing the Ubuntu system, only the Windows system remains, but the GRUB interface still appears every time the computer boots. In this case, you need to delete the old Ubuntu EFI partition. ","date":"2023-06-12","objectID":"/efi_partition/:0:0","tags":["Storage/Partition","Linux"],"title":"Mounting the EFI partition in Windows OS","uri":"/efi_partition/"},{"categories":["Mathematical Physics"],"content":"1 Differential Forms Before introducing the concept of curl, we need to first introduce differential forms and the exterior derivative. An n-form can be defined as an alternating multilinear mapping $\\omega:(T_p^*M)^n\\rightarrow \\mathbb{R}$. It maps multiple vectors to a real number. Additionally, it satisfies the alternating property, meaning that exchanging two input vectors results in an output multiplied by a negative sign. Therefore, an n-form can be explicitly defined as follows: $$ \\omega^1\\wedge \\omega^2\\wedge\\cdots\\wedge \\omega^n(v_1,v_2,\\cdots,v_n)= \\begin{vmatrix} \\omega^1(v_1) \u0026 \\cdots \u0026 \\omega^{1}(v_n) \\\\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\\ \\omega^n(v_1) \u0026 \\cdots \u0026 \\omega^n(v_n) \\end{vmatrix}\\in \\mathbb{R} $$ The set of all n-forms on $T_p^*M$ can be written as $\\bigwedge_n(T_p^*M)$. As for “differential forms,” they differ from “forms” in that they are the “forms’ fields,” meaning that at each point on the manifold, there resides a form. In other words, “forms” are specific to a point, while “differential forms” are specific to the entire manifold. ","date":"2023-06-10","objectID":"/curl_in_n_dimension/:0:1","tags":["Vector Calculus"],"title":"Curl in high dimension","uri":"/curl_in_n_dimension/"},{"categories":["Mathematical Physics"],"content":"2 Exterior Derivative The definition of the exterior derivative is as follows: The exterior derivative is a mapping $\\mathrm{d}: \\bigwedge^n(T_p^*M) \\rightarrow \\bigwedge^{(n+1)}(T_p^*M)$, which acts on an differential n-form: $\\varphi = \\sum_I f_I \\mathrm{d}x^I = \\sum_{(i_1,\\cdots,i_n)} f_{(i_1,\\cdots,i_n)} \\mathrm{d}x^{i_1}\\wedge\\cdots\\wedge\\mathrm{d}x^{i_n}$, and yields an differential (n+1)-form: $\\mathrm{d}\\varphi = \\sum_I \\sum_i \\frac{\\partial f_I}{\\partial x_i} \\mathrm{d}x_i\\wedge x_I$. Comment These indices are quite all over the place. Let’s see the example below instead. Example For a differential 2-form on a 3-dimensional manifold: $\\varphi = z^2\\mathrm{d}x\\wedge\\mathrm{d}y + x\\sin y\\,\\mathrm{d}y\\wedge \\mathrm{d}z$, its exterior derivative is given by: $$\\begin{aligned} \\mathrm{d}\\varphi \u0026= \\left(\\frac{\\partial z^2}{\\partial x}\\mathrm{d}x + \\frac{\\partial z^2}{\\partial y}\\mathrm{d}y + \\frac{\\partial z^2}{\\partial z}\\mathrm{d}z\\right)\\wedge\\mathrm{d}x\\wedge\\mathrm{d}y \\\\\\ \u0026 + \\left(\\frac{\\partial (x\\sin y)}{\\partial x}\\mathrm{d}x + \\frac{\\partial (x\\sin y)}{\\partial y}\\mathrm{d}y + \\frac{\\partial (x\\sin y)}{\\partial z}\\mathrm{d}z\\right)\\wedge\\mathrm{d}y\\wedge\\mathrm{d}z \\\\\\ \u0026= (2z + \\sin y)\\,\\mathrm{d}x\\wedge\\mathrm{d}y\\wedge\\mathrm{d}z \\end{aligned} $$ ","date":"2023-06-10","objectID":"/curl_in_n_dimension/:0:2","tags":["Vector Calculus"],"title":"Curl in high dimension","uri":"/curl_in_n_dimension/"},{"categories":["Mathematical Physics"],"content":"3 Curl in N Dimensions In the following example, we will explore the relationship between curl and exterior derivative: Example: On a three-dimensional manifold, when the exterior derivative operator $\\mathrm{d}$ acts on a 1-form, it yields a 2-form: $$ \\begin{aligned} \\mathrm{d}(f_i\\mathrm{d}x^i) \u0026= \\frac{\\partial f_1}{\\partial x^1}\\mathrm{d}x^1\\wedge\\mathrm{d}x^1 + \\frac{\\partial f_1}{\\partial x^2}\\mathrm{d}x^2\\wedge\\mathrm{d}x^1 + \\frac{\\partial f_1}{\\partial x^3}\\mathrm{d}x^3\\wedge\\mathrm{d}x^1 \\\\ \u0026\\quad+ \\frac{\\partial f_2}{\\partial x^1}\\mathrm{d}x^1\\wedge\\mathrm{d}x^2 + \\frac{\\partial f_2}{\\partial x^2}\\mathrm{d}x^2\\wedge\\mathrm{d}x^2 + \\frac{\\partial f_2}{\\partial x^3}\\mathrm{d}x^3\\wedge\\mathrm{d}x^2 \\\\ \u0026\\quad+ \\frac{\\partial f_3}{\\partial x^1}\\mathrm{d}x^1\\wedge\\mathrm{d}x^3 + \\frac{\\partial f_3}{\\partial x^2}\\mathrm{d}x^2\\wedge\\mathrm{d}x^3 + \\frac{\\partial f_3}{\\partial x^3}\\mathrm{d}x^3\\wedge\\mathrm{d}x^3 \\end{aligned} $$ Applying the Hodge star operator once, it yields a 1-form: $$ \\begin{aligned} \\star \\mathrm{d}(f_i\\mathrm{d}x^i) \u0026= \\phantom{+\\frac{\\partial f_1}{\\partial x^2}\\mathrm{d}x^3} -\\frac{\\partial f_1}{\\partial x^2}\\mathrm{d}x^3 + \\frac{\\partial f_1}{\\partial x^3}\\mathrm{d}x^2 \\\\ \u0026\\phantom{=}+ \\frac{\\partial f_2}{\\partial x^1}\\mathrm{d}x^3 \\phantom{\\,\\,\\,-\\frac{\\partial f_1}{\\partial x^2}\\mathrm{d}x^3} -\\frac{\\partial f_2}{\\partial x^3}\\mathrm{d}x^1 \\\\ \u0026\\phantom{=} -\\frac{\\partial f_3}{\\partial x^1}\\mathrm{d}x^2 + \\frac{\\partial f_3}{\\partial x^2}\\mathrm{d}x^1 \\\\ \u0026= \\left(\\frac{\\partial f_3}{\\partial x^2}-\\frac{\\partial f_2}{\\partial x^3}\\right)\\mathrm{d}x^1 + \\left(\\frac{\\partial f_1}{\\partial x^3}-\\frac{\\partial f_3}{\\partial x^1}\\right)\\mathrm{d}x^2 + \\left(\\frac{\\partial f_2}{\\partial x^1}-\\frac{\\partial f_1}{\\partial x^2}\\right)\\mathrm{d}x^3 \\end{aligned} $$ It can be expressed as the inner product of the curl and a tangent vector: $\\star\\mathrm{d}f:\\star\\mathrm{d}f(v)=\\langle \\nabla \\times f^{\\sharp}\\mid v \\rangle$ For now, without introducing the Hodge star operator, you only need to know that on a three-dimensional manifold, the Hodge operator applied to an differential n-form yields an differential (3-n)-form. Specifically, if the manifold is equipped with an inner product $\\langle\\mathrm{d}x^i,\\mathrm{d}x^j\\rangle=\\delta^{j}_i$, then we have: $$ \\star(\\mathrm{d}x^i \\wedge \\mathrm{d}x^j) = \\mathrm{d}x^k $$ $$\\star\\mathrm{d}x^i = \\mathrm{d}x^j\\wedge \\mathrm{d}x^k$$ $$\\star(f\\, \\mathrm{d}x^i \\wedge\\mathrm{d}x^j\\wedge \\mathrm{d}x^k) = f$$ $$\\star f = f\\mathrm{d}x^i \\wedge\\mathrm{d}x^j\\wedge \\mathrm{d}x^k$$ where $(i,j,k)$ is an even permutation of $(1,2,3)$. Also, note that we use a raised symbol: $\\sharp$. This is because the curl operates on tangent vector fields, not cotangent vector fields. Specifically, the curl $\\nabla\\times$ maps a tangent vector field to another tangent vector field: $\\Gamma(TM)\\rightarrow \\Gamma(TM)$. However, $f\\in \\Gamma(T^*M)$ is a cotangent vector field (a 1-form), so we first need to “raise” it to a tangent vector field: $f^\\sharp\\in \\Gamma(TM)$. This is actually the well-known index raising and lowering in physics: $g^{ij}X_i=X^j$. Similarly, $\\flat$ represents lowering a tangent vector field to a cotangent vector field: $g_{ij}X^i=X_j$. Returning to the previous example, we have a canonical isomorphism induced by the inner product: $$ \\sharp: \\star \\mathrm{d}f \\mapsto \\nabla\\times f^\\sharp $$ or written as: $$ (\\star \\mathrm{d}f)^\\sharp = \\nabla\\times f^\\sharp $$ or written as: $$ \\star \\mathrm{d}f(v) = \\langle\\nabla\\times f^\\sharp\\mid v\\rangle $$ where $f$ is a 1-form. We can also write it as: $\\nabla\\times F=(\\star \\mathrm{d} (F^\\flat))^\\sharp$ where $F=f^\\sharp$ is a tangent vector field, and $f$ is a cotangent vector field (a 1-form). Inspired by the above example, we can define the curl as: $$ \\begin{aligned} (\\nabla\\times) : \\quad \u0026 \\Gamma(TM)\\rightarrow \\Gamma\\left(\\bigwedge^{n-2}TM\\right) \\\\ \u0026 F \\mapsto (\\star \\mathrm{d} (F^\\flat))^\\sharp \\end{aligned} $$ whe","date":"2023-06-10","objectID":"/curl_in_n_dimension/:0:3","tags":["Vector Calculus"],"title":"Curl in high dimension","uri":"/curl_in_n_dimension/"},{"categories":["Mathematical Physics"],"content":"1 Introduction In physics textbooks, we often come across the terms “pseudo-vector” and “pseudo-scalar.” In fact, on a 3-dimensional manifold, a “pseudo-vector” is the exterior product of two tangent vectors, denoted as $v\\in T_pM\\wedge T_pM=\\bigwedge^2(T_pM)$, while a “pseudo-scalar” is the exterior product of three tangent vectors, denoted as $s\\in T_pM\\wedge T_pM\\wedge T_pM=\\bigwedge^3(T_pM)$. When equipped with an inner product (or non-degenerate bilinear form), there exists a Hodge duality between $\\bigwedge^2(T_pM)$ and $\\bigwedge^1(T_pM)$, which leads us to mistakenly consider the pseudo-vector as a vector. Similarly, due to the Hodge duality between $\\bigwedge^3(T_pM)$ and $\\bigwedge^0(T_pM)$ (scalar fields), we mistakenly treat the pseudo-scalar as a scalar. In fact, a pseudo-vector on a 3-dimensional manifold is mathematically equivalent to a 2-vector (bivector). It is similar in definition to a 2-form, with the distinction that a 2-vector belongs to the exterior product of the tangent space, $v\\in\\bigwedge^2(T_pM)$, while a 2-form belongs to the exterior product of the cotangent space, $\\omega\\in\\bigwedge^2(T_p^*M)$. ","date":"2023-06-10","objectID":"/pseudovectors/:1:0","tags":["Exterior Algebra"],"title":"What on earth are the pseudovectors?","uri":"/pseudovectors/"},{"categories":["Mathematical Physics"],"content":"2 Space Inversion Recalling why we call “pseudo-vectors” pseudo-vectors in the first place. It is because they exhibit exotic behaviors under space inversion transformations. However, if we consider them as the exterior product of two vectors, all the peculiar behaviors can be explained. Specifically, as shown in the figure below, under a space inversion transformation, the magnetic field reverses its direction. It’s similar to you moving in one direction, but the reflection of you in the mirror moves in the opposite direction, which is a spooky and paranormal event. The magnetic field is a bivector. If you consider it as a vector, you will encounter this spooky phenomenon in the picture: the magnetic field takes a look in the mirror and finds its head turned into feet. In fact, the magnetic field at point $p$ is not a vector but a bivector, denoted as $B|_p\\in (T_pM)\\wedge (T_pM)$. Its basis consists of $\\frac{\\partial}{\\partial x}\\wedge \\frac{\\partial}{\\partial y},\\,\\frac{\\partial}{\\partial y}\\wedge \\frac{\\partial}{\\partial z},\\,\\frac{\\partial}{\\partial z}\\wedge \\frac{\\partial}{\\partial x}$. So, there is no paranormal event happening. Under a space inversion transformation, both vectors corresponding to the magnetic field actually point in the correct directions. It’s just that humans insist on using the right-hand rule and treat a bivector as a vector, which leads to the appearance of this strange phenomenon. Although bivectors are well-defined in mathematics, we still want to ask the question: How do we visualize a bivector? The answer is: We can represent a bivector as an oriented surface element. Different-shaped surface elements that are parallel to each other and have the same area represent the same bivector. In other words, the same bivector can be depicted in infinitely many ways, as long as they are parallel, have the same area, and have the same orientation. Parallel surface elements with the same area and orientation represent the same bivector. In practice, treating a bivector as a vector using the right-hand rule is only applicable in three-dimensional manifolds. This is because only in three-dimensional manifolds does three minus two exactly equal one. In four-dimensional manifolds, since four minus two equals two, we can only dualize a bivector into another bivector, not a vector. In five-dimensional manifolds, a bivector can be dualized into a trivector, and so on. In an n-dimensional manifold, a bivector can be dualized into an (n-2)-vector. ","date":"2023-06-10","objectID":"/pseudovectors/:2:0","tags":["Exterior Algebra"],"title":"What on earth are the pseudovectors?","uri":"/pseudovectors/"},{"categories":["Mathematical Physics"],"content":"3 Maxwell Equations in Exterior Algebra By the way, the electric field is also a bivector. Its basis consists of $\\frac{\\partial}{\\partial t}\\wedge \\frac{\\partial}{\\partial x},\\,\\frac{\\partial}{\\partial t}\\wedge \\frac{\\partial}{\\partial y},\\,\\frac{\\partial}{\\partial t}\\wedge \\frac{\\partial}{\\partial z}$, involving a time dimension. The reason it doesn’t appear as a “pseudo-vector” is that we only consider space inversion transformations rather than time inversion transformations. If we consider the electromagnetic 2-form in the cotangent bundle (using natural units): $$ \\begin{aligned} F\u0026=E_x\\mathrm{d}t\\wedge\\mathrm{d}x+E_y\\mathrm{d}t\\wedge\\mathrm{d}y+E_z\\mathrm{d}t\\wedge\\mathrm{d}z \\\\ \u0026+B_x \\mathrm{d}y\\wedge\\mathrm{d}z + B_y \\mathrm{d}z\\wedge\\mathrm{d}x + B_z\\mathrm{d}x\\wedge\\mathrm{d}y \\end{aligned} $$ Since we can raise or lower the indices of a tensor with the help of a metric tensor, we can also write a $(2,0)$-type electromagnetic tensor with the basis formed by the exterior product of $\\frac{\\partial}{\\partial t},\\frac{\\partial}{\\partial x},\\frac{\\partial}{\\partial y},\\frac{\\partial}{\\partial z}$. However, for now, let’s adopt the $(0,2)$-type antisymmetric tensor (differential form) because it allows us to utilize the symbol $\\mathrm{d}$ for the exterior derivative. Now, let’s consider the current 1-form: $J=-\\rho\\mathrm{d}t+J_x\\mathrm{d}x+J_y\\mathrm{d}y+J_z\\mathrm{d}z$. Thus, under the Minkowski metric $\\text{diag}(-1,1,1,1)$, Maxwell’s equations can be expressed in a concise form: $$ \\left\\{\\quad \\begin{aligned} \\mathrm{d}F\u0026=0 \\\\ \\star \\, \\mathrm{d}\\star F \u0026= J \\end{aligned} \\right. $$ Here, $\\star$ represents the Hodge star operator (also known as Hodge duality). As can be seen, in the language of exterior algebra, the electromagnetic field is a 2-vector or a 2-form, rather than a vector or a 1-form. The current is indeed a vector (or a 1-form), though. ","date":"2023-06-10","objectID":"/pseudovectors/:3:0","tags":["Exterior Algebra"],"title":"What on earth are the pseudovectors?","uri":"/pseudovectors/"},{"categories":["Diary"],"content":"I recently discovered this fantastic tool for creating personal websites - Hugo. Feels really cool and user-friendly! Plan to gradually migrate my blogs from Zhihu to here in the future. ","date":"2023-06-10","objectID":"/blog_migration/:0:0","tags":["Diary"],"title":"Blog Migration","uri":"/blog_migration/"},{"categories":null,"content":"\rThis is Haifei's personal website. He loves physics (his major), mathematics (not very good at it), and EECS (just for fun). In terms of EECS, he is particularly interested in the embedded systems. In his spare time, he enjoys playing the keyboard, drums, and appreciating jazz music.\rHe graduated from Wuhan University with a bachelor's degree and is currently pursuing a Ph.D. at the National University of Singapore - Centre for Quantum Technologies.\r","date":"2023-06-09","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Mathematical Physics"],"content":"TBD Chinese version here ","date":"2023-06-09","objectID":"/differential_geometry/:0:0","tags":["Differential Geometry","Lie Algebra"],"title":"A Beginners Guide to Differential Geometry and Lie Algebras","uri":"/differential_geometry/"}]